import { parseMarkdown } from "@/lib/markdown";
import { useEffect, useRef, useImperativeHandle, forwardRef, useCallback } from "react";
import { useFileStore } from "@/stores/useFileStore";
import { useAIStore } from "@/stores/useAIStore";
import { useSplitStore } from "@/stores/useSplitStore";
import { useUIStore } from "@/stores/useUIStore";
import { parseLuminaLink } from "@/lib/annotations";
import { EditorState, StateField, StateEffect, Compartment, Facet, Extension } from "@codemirror/state";
import {
  EditorView,
  keymap,
  Decoration,
  DecorationSet,
  ViewPlugin,
  ViewUpdate,
  WidgetType,
} from "@codemirror/view";
import { defaultKeymap, history, historyKeymap } from "@codemirror/commands";
import { markdown, markdownLanguage } from "@codemirror/lang-markdown";
import { syntaxTree } from "@codemirror/language";
import katex from "katex";
import { common, createLowlight } from "lowlight";

// Initialize lowlight with common languages
const lowlight = createLowlight(common);

/** ç¼–è¾‘å™¨è§†å›¾æ¨¡å¼ */
export type ViewMode = 'reading' | 'live' | 'source';

// ============ 1. æ ¸å¿ƒæ¶æ„ï¼šCompartments & Facets ============
// Compartments: ç”¨äºåœ¨ä¸é”€æ¯ View çš„æƒ…å†µä¸‹åŠ¨æ€åˆ‡æ¢é…ç½®
const viewModeCompartment = new Compartment();  // ç®¡ç† Widget å’Œæ¨¡å¼ç‰¹å®šçš„æ’ä»¶
const readOnlyCompartment = new Compartment();  // ç®¡ç†åªè¯»çŠ¶æ€
const themeCompartment = new Compartment();     // ç®¡ç†ä¸»é¢˜ (é¢„ç•™)

// Facet: æ§åˆ¶ Widget çš„äº¤äº’è¡Œä¸º
// Reading æ¨¡å¼ -> false (æ°¸è¿œæ¸²æŸ“ Widget)
// Live æ¨¡å¼ -> true (é€‰ä¸­æ—¶å¡Œç¼©å›æºç )
const collapseOnSelectionFacet = Facet.define<boolean, boolean>({
  combine: values => values[0] ?? false
});

// ============ 2. å…¨å±€çŠ¶æ€ç®¡ç† ============
// é¼ æ ‡æ‹–æ‹½çŠ¶æ€ï¼šç”¨äºé˜²æ­¢æ‹–æ‹½é€‰æ‹©æ—¶ Widget é¢‘ç¹é—ªçƒ
const setMouseSelecting = StateEffect.define<boolean>();

const mouseSelectingField = StateField.define<boolean>({
  create: () => false,
  update(value, tr) {
    for (const effect of tr.effects) {
      if (effect.is(setMouseSelecting)) return effect.value;
    }
    return value;
  },
});

// ============ 3. æ ¸å¿ƒé€»è¾‘ï¼šåˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºæºç  ============
// è¿™ä¸ªå‡½æ•°ç»Ÿä¸€äº†æ‰€æœ‰ Widget çš„æ˜¾ç¤º/éšè—é€»è¾‘
const shouldShowSource = (state: EditorState, from: number, to: number): boolean => {
  // 1. æ£€æŸ¥ Facet é…ç½® (Reading=false, Live=true)
  const shouldCollapse = state.facet(collapseOnSelectionFacet);
  if (!shouldCollapse) return false; // Reading æ¨¡å¼ï¼šå§‹ç»ˆæ¸²æŸ“ Widget

  // 2. æ‹–æ‹½æ—¶ä¿æŒæ¸²æŸ“
  if (state.field(mouseSelectingField, false)) return false;

  // 3. æ£€æŸ¥å…‰æ ‡é‡å  (Live æ¨¡å¼)
  for (const range of state.selection.ranges) {
    if (range.from <= to && range.to >= from) return true;
  }
  return false;
};

interface CodeMirrorEditorProps {
  content: string;
  onChange: (content: string) => void;
  className?: string;
  isDark?: boolean;
  /** è§†å›¾æ¨¡å¼ï¼šreading(åªè¯»æ¸²æŸ“) / live(å®æ—¶é¢„è§ˆ) / source(æºç ) */
  viewMode?: ViewMode;
  /** @deprecated ä½¿ç”¨ viewMode ä»£æ›¿ */
  livePreview?: boolean;
}

// æš´éœ²ç»™çˆ¶ç»„ä»¶çš„æ–¹æ³•
export interface CodeMirrorEditorRef {
  getScrollLine: () => number;
  scrollToLine: (line: number) => void;
}

// è‡ªå®šä¹‰ä¸»é¢˜ - ä½¿ç”¨ CSS å˜é‡æ”¯æŒä¸»é¢˜åˆ‡æ¢
const editorTheme = EditorView.theme({
  "&": {
    backgroundColor: "transparent",
    fontSize: "16px",
    height: "100%",
  },
  ".cm-content": {
    fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    padding: "16px 0",
    caretColor: "hsl(var(--primary))",
  },
  ".cm-line": {
    padding: "0 16px",
    paddingLeft: "16px", // åŸºç¡€å·¦è¾¹è·
    lineHeight: "1.75",
    position: "relative", // ä½œä¸ºç»å¯¹å®šä½çš„é”šç‚¹
  },
  ".cm-cursor": {
    borderLeftColor: "hsl(var(--primary))",
    borderLeftWidth: "2px",
  },
  // é€‰æ‹©èƒŒæ™¯è‰² - æ·¡è“è‰²
  ".cm-selectionBackground": {
    backgroundColor: "rgba(147, 197, 253, 0.35) !important", // æ·¡è“è‰² (blue-300)
  },
  "&.cm-focused .cm-selectionBackground": {
    backgroundColor: "rgba(147, 197, 253, 0.45) !important", // èšç„¦æ—¶ç¨æ·±
  },
  // è¦†ç›–æµè§ˆå™¨åŸç”Ÿé€‰æ‹©æ ·å¼
  "& ::selection": {
    backgroundColor: "rgba(147, 197, 253, 0.45) !important",
  },
  "& ::-moz-selection": {
    backgroundColor: "rgba(147, 197, 253, 0.45) !important",
  },
  ".cm-gutters": {
    display: "none",
  },
  // Markdown æ ‡é¢˜ - ä½¿ç”¨ä¸»é¢˜å˜é‡
  ".cm-header-1": { 
    fontSize: "2em", 
    fontWeight: "700", 
    lineHeight: "1.3",
    color: "hsl(var(--md-heading, var(--foreground)))",
  },
  ".cm-header-2": { 
    fontSize: "1.5em", 
    fontWeight: "600", 
    lineHeight: "1.4",
    color: "hsl(var(--md-heading, var(--foreground)))",
  },
  ".cm-header-3": { 
    fontSize: "1.25em", 
    fontWeight: "600", 
    lineHeight: "1.5",
    color: "hsl(var(--md-heading, var(--foreground)))",
  },
  ".cm-header-4": { 
    fontSize: "1.1em", 
    fontWeight: "600",
    color: "hsl(var(--md-heading, var(--foreground)))",
  },
  ".cm-header-5, .cm-header-6": {
    fontWeight: "600",
    color: "hsl(var(--md-heading, var(--foreground)))",
  },
  // æ ‡é¢˜è¡Œå¾€å·¦ç§»åŠ¨
  ".cm-line.cm-heading-line": {
    paddingLeft: "0 !important",
    marginLeft: "16px",
  },
  // ç²—ä½“/æ–œä½“
  ".cm-strong": { 
    fontWeight: "700",
    color: "hsl(var(--md-bold, var(--foreground)))",
  },
  ".cm-emphasis": { 
    fontStyle: "italic",
    color: "hsl(var(--md-italic, var(--foreground)))",
  },
  ".cm-strikethrough": { textDecoration: "line-through" },
  // é“¾æ¥
  ".cm-link": { 
    color: "hsl(var(--md-link, var(--primary)))", 
    textDecoration: "underline",
  },
  ".cm-url": { 
    color: "hsl(var(--muted-foreground))",
  },
  // WikiLink åŒå‘é“¾æ¥ - Ctrl+Click è·³è½¬
  ".cm-wikilink": {
    color: "hsl(var(--primary))",
    textDecoration: "underline",
    cursor: "text", // é»˜è®¤æ–‡æœ¬å…‰æ ‡ï¼Œè¡¨ç¤ºå¯ç¼–è¾‘
    borderRadius: "2px",
    transition: "background-color 0.15s ease",
    "&:hover": {
      backgroundColor: "hsl(var(--primary) / 0.1)",
    },
  },
  // ä»£ç 
  ".cm-code, .cm-inline-code": {
    backgroundColor: "hsl(var(--md-code-bg, var(--muted)))",
    color: "hsl(var(--md-code, var(--foreground)))",
    padding: "2px 4px",
    borderRadius: "3px",
    fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
  },
  // ä»£ç å—
  ".cm-codeblock": {
    backgroundColor: "hsl(var(--md-code-block-bg, var(--muted)))",
    color: "hsl(var(--md-code-block, var(--foreground)))",
  },
  // å¼•ç”¨
  ".cm-quote": {
    color: "hsl(var(--md-blockquote, var(--muted-foreground)))",
    fontStyle: "italic",
  },
  // åˆ—è¡¨æ ‡è®°
  ".cm-list-bullet, .cm-list-number": {
    color: "hsl(var(--md-list-marker, var(--primary)))",
  },
  // Live Preview è¯­æ³•æ ‡è®° - æ‚¬æŒ‚å¸ƒå±€
  ".cm-formatting": {
    color: "hsl(var(--muted-foreground) / 0.6)",
  },
  // æ‚¬æŒ‚å¸ƒå±€ï¼šæ ‡è®°ç¬¦å·ç»å¯¹å®šä½åˆ°å·¦ä¾§ gutterï¼ˆç”¨äºè¡Œé¦–æ ‡è®° #, -, >ï¼‰
  ".cm-formatting-hanging": {
    position: "absolute",
    right: "100%", // æ‚¬æŒ‚åœ¨å†…å®¹å·¦è¾¹
    marginRight: "8px",
    color: "hsl(var(--muted-foreground) / 0.6)",
    fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
    fontSize: "0.9em",
    userSelect: "none",
    pointerEvents: "none",
    whiteSpace: "nowrap",
  },
  // è¡Œå†…æ ‡è®°ï¼ˆ**, *, ==, `ï¼‰- ä½¿ç”¨ max-width åŠ¨ç”»å±•å¼€
  ".cm-formatting-inline": {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    whiteSpace: "nowrap",
    verticalAlign: "baseline",
    color: "hsl(var(--muted-foreground) / 0.6)",
    fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
    fontSize: "0.85em",
    // åˆå§‹çŠ¶æ€ï¼šæ”¶ç¼©éšè—
    maxWidth: "0",
    opacity: "0",
    // ä¸æ»‘çš„è´å¡å°”æ›²çº¿åŠ¨ç”»
    transition: "max-width 0.25s cubic-bezier(0.2, 0, 0.2, 1), opacity 0.2s ease-out",
  },
  // æ¿€æ´»è¡Œæ—¶å±•å¼€è¡Œå†…æ ‡è®°
  ".cm-formatting-inline-visible": {
    maxWidth: "4ch", // è¶³å¤Ÿå®¹çº³ **, ==, ` ç­‰
    opacity: "1",
    margin: "0 1px", // å±•å¼€æ—¶ç»™ä¸€ç‚¹å‘¼å¸ç©ºé—´
  },
  // éšè—è¯­æ³•æ ‡è®°ï¼ˆéæ¿€æ´»è¡Œï¼Œç”¨äºè¡Œé¦–æ ‡è®°ï¼‰
  ".cm-formatting-hidden": {
    display: "none",
  },
  // æ ‡ç­¾
  ".cm-tag, .cm-hashtag": {
    color: "hsl(var(--md-tag, var(--primary)))",
  },
  // æ°´å¹³çº¿
  ".cm-hr": {
    color: "hsl(var(--md-hr, var(--border)))",
  },
  // æ•°å­¦å…¬å¼æ ·å¼
  ".cm-math-inline": {
    display: "inline-block",
    verticalAlign: "middle",
  },
  ".cm-math-block": {
    display: "block",
    textAlign: "center",
    padding: "0.5em 0",
    overflow: "auto",
  },
  ".cm-math-error": {
    color: "hsl(0 70% 50%)",
    fontFamily: "monospace",
  },
});

// ============ 4. Widgets å®ç° (ç¡®ä¿ eq æ–¹æ³•æ­£ç¡®) ============
// KaTeX æ•°å­¦å…¬å¼ Widget
class MathWidget extends WidgetType {
  constructor(
    readonly formula: string,
    readonly displayMode: boolean
  ) {
    super();
  }

  eq(other: MathWidget) {
    return other.formula === this.formula && other.displayMode === this.displayMode;
  }

  toDOM() {
    const container = document.createElement("span");
    container.className = this.displayMode ? "cm-math-block" : "cm-math-inline";
    
    try {
      katex.render(this.formula, container, {
        displayMode: this.displayMode,
        throwOnError: false,
        trust: true,
        strict: false, // å¿½ç•¥ LaTeX è­¦å‘Šï¼ˆå¦‚ display mode ä¸­çš„æ¢è¡Œç¬¦ï¼‰
      });
    } catch (e) {
      container.textContent = this.formula;
      container.className += " cm-math-error";
    }
    
    return container;
  }

  ignoreEvent() {
    return false;
  }
}

// Table Widget
class TableWidget extends WidgetType {
  constructor(readonly markdown: string) {
    super();
  }

  eq(other: TableWidget) {
    return other.markdown === this.markdown;
  }

  toDOM() {
    const container = document.createElement("div");
    container.className = "cm-table-widget reading-view prose max-w-none";
    try {
      container.innerHTML = parseMarkdown(this.markdown);
    } catch (e) {
      console.warn("Table render error:", e);
      container.textContent = this.markdown;
    }
    return container;
  }

  ignoreEvent() {
    return true;
  }
}

// Code Block Widget
class CodeBlockWidget extends WidgetType {
  constructor(readonly code: string, readonly language: string) {
    super();
  }

  eq(other: CodeBlockWidget) {
    return other.code === this.code && other.language === this.language;
  }

  toDOM() {
    const container = document.createElement("div");
    container.className = "cm-code-block-widget relative group";
    
    const pre = document.createElement("pre");
    const code = document.createElement("code");
    code.className = "hljs";

    if (this.language) {
      code.classList.add(`language-${this.language}`);
    }
    
    // ä½¿ç”¨ lowlight åŒæ­¥é«˜äº® (Widget ç¼“å­˜æœºåˆ¶ä¿è¯æ€§èƒ½)
    let highlighted = false;
    if (this.language) {
      try {
        if (lowlight.registered(this.language)) {
          const tree = lowlight.highlight(this.language, this.code);
          this.hastToDOM(tree.children, code);
          highlighted = true;
        }
      } catch (e) {
        console.warn("Highlight error:", e);
      }
    }
    
    if (!highlighted) code.textContent = this.code;
    
    pre.appendChild(code);
    container.appendChild(pre);

    if (this.language) {
      const label = document.createElement("div");
      label.className = "absolute top-1 right-2 text-xs text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity select-none pointer-events-none font-sans";
      label.textContent = this.language;
      container.appendChild(label);
    }
    
    return container;
  }

  hastToDOM(nodes: any[], parent: HTMLElement) {
    for (const node of nodes) {
      if (node.type === 'text') parent.appendChild(document.createTextNode(node.value));
      else if (node.type === 'element') {
        const el = document.createElement(node.tagName);
        if (node.properties?.className) el.className = node.properties.className.join(' ');
        if (node.children) this.hastToDOM(node.children, el);
        parent.appendChild(el);
      }
    }
  }

  ignoreEvent() {
    return false;
  }
}

// æ‚¬æŒ‚æ ‡è®° Widget - åœ¨å·¦ä¾§ gutter æ˜¾ç¤ºæ ‡è®°ç¬¦å·
class HangingMarkWidget extends WidgetType {
  constructor(readonly mark: string) {
    super();
  }

  eq(other: HangingMarkWidget) {
    return other.mark === this.mark;
  }

  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting-hanging";
    span.textContent = this.mark;
    return span;
  }

  ignoreEvent() {
    return true;
  }
}

// Callout Icon Widget
class CalloutIconWidget extends WidgetType {
  constructor(readonly icon: string) {
    super();
  }

  eq(other: CalloutIconWidget) {
    return other.icon === this.icon;
  }

  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-callout-icon";
    span.textContent = this.icon;
    span.style.cssText = "margin-right: 6px; font-size: 1.1em;";
    return span;
  }

  ignoreEvent() {
    return true;
  }
}

// ============ 5. StateFields (ä½¿ç”¨ Facet æ§åˆ¶æ¸²æŸ“é€»è¾‘) ============
// WikiLink å§‹ç»ˆæ˜¾ç¤º
const wikiLinkStateField = StateField.define<DecorationSet>({
  create: buildWikiLinkDecorations,
  update(deco, tr) {
    return tr.docChanged ? buildWikiLinkDecorations(tr.state) : deco.map(tr.changes);
  },
  provide: f => EditorView.decorations.from(f),
});

function buildWikiLinkDecorations(state: EditorState): DecorationSet {
  const decorations: any[] = [];
  const wikiLinkRegex = /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;
  let match;

  while ((match = wikiLinkRegex.exec(state.doc.toString())) !== null) {
    decorations.push(
      Decoration.mark({
        class: "cm-wikilink",
        attributes: { "data-wikilink": match[1].trim() }
      }).range(match.index, match.index + match[0].length)
    );
  }
  return Decoration.set(decorations);
}

// Code Block æ¸²æŸ“ StateField
const codeBlockStateField = StateField.define<DecorationSet>({
  create: buildCodeBlockDecorations,
  update(deco, tr) {
    if (tr.docChanged || tr.selection || tr.reconfigured || tr.effects.some(e => e.is(setMouseSelecting))) {
      return buildCodeBlockDecorations(tr.state);
    }
    return deco.map(tr.changes);
  },
  provide: f => EditorView.decorations.from(f),
});

function buildCodeBlockDecorations(state: EditorState): DecorationSet {
  const decorations: any[] = [];
  syntaxTree(state).iterate({
    enter: (node) => {
      if (node.name === "FencedCode") {
        if (shouldShowSource(state, node.from, node.to)) return;

        const text = state.doc.sliceString(node.from, node.to);
        const lines = text.split('\n');
        if (lines.length < 2) return;
        
        const language = lines[0].replace(/^\s*`{3,}/, "").trim();
        const codeLines = lines.slice(1);
        const lastLine = codeLines[codeLines.length - 1];
        if (lastLine && /^\s*`{3,}\s*$/.test(lastLine)) codeLines.pop();

        decorations.push(
          Decoration.replace({
            widget: new CodeBlockWidget(codeLines.join('\n'), language),
            block: true,
          }).range(node.from, node.to)
        );
      }
    },
  });
  return Decoration.set(decorations);
}

// Table æ¸²æŸ“ StateField
const tableStateField = StateField.define<DecorationSet>({
  create: buildTableDecorations,
  update(deco, tr) {
    if (tr.docChanged || tr.selection || tr.reconfigured || tr.effects.some(e => e.is(setMouseSelecting))) {
      return buildTableDecorations(tr.state);
    }
    return deco.map(tr.changes);
  },
  provide: f => EditorView.decorations.from(f),
});

function buildTableDecorations(state: EditorState): DecorationSet {
  const decorations: any[] = [];
  syntaxTree(state).iterate({
    enter: (node) => {
      if (node.name === "Table") {
        if (shouldShowSource(state, node.from, node.to)) return;
        decorations.push(
          Decoration.replace({
            widget: new TableWidget(state.doc.sliceString(node.from, node.to)),
            block: true,
          }).range(node.from, node.to)
        );
      }
    },
  });
  return Decoration.set(decorations);
}

// Math æ¸²æŸ“ StateField - ä½¿ç”¨ StateField ä»¥æ”¯æŒ block decorations
const mathStateField = StateField.define<DecorationSet>({
  create(state) {
    return buildMathDecorations(state);
  },
  update(decorations, transaction) {
    // æ£€æŸ¥æ˜¯å¦æœ‰é¼ æ ‡çŠ¶æ€å˜åŒ–
    const mouseStateChanged = transaction.effects.some(e => e.is(setMouseSelecting));
    
    // å½“æ–‡æ¡£å†…å®¹å˜åŒ–ã€é€‰æ‹©å˜åŒ–æˆ–é¼ æ ‡çŠ¶æ€å˜åŒ–æ—¶æ›´æ–°è£…é¥°
    if (transaction.docChanged || transaction.selection || mouseStateChanged) {
      return buildMathDecorations(transaction.state);
    }
    return decorations.map(transaction.changes);
  },
  provide: (f) => EditorView.decorations.from(f),
});

function buildMathDecorations(state: EditorState): DecorationSet {
  try {
    const decorations: any[] = [];
    const doc = state.doc.toString();
    const selection = state.selection;
    
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨é¼ æ ‡æ‹–æ‹½
    const isMouseSelecting = state.field(mouseSelectingField, false) ?? false;
    
    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥èŒƒå›´æ˜¯å¦ä¸å½“å‰é€‰æ‹©é‡å 
    // é¼ æ ‡æ‹–æ‹½æ—¶ï¼Œä¸æ˜¾ç¤ºæºç ï¼ˆä¿æŒæ¸²æŸ“çŠ¶æ€ï¼‰
    const isSelected = (from: number, to: number) => {
      // æ‹–æ‹½ä¸­æ—¶ï¼Œä¸è§¦å‘é€‰ä¸­é€»è¾‘ï¼ˆä¿æŒæ¸²æŸ“ï¼‰
      if (isMouseSelecting) return false;
      
      for (const range of selection.ranges) {
        // åªè¦é€‰æ‹©èŒƒå›´ï¼ˆåŒ…æ‹¬å…‰æ ‡ï¼‰ä¸å…¬å¼èŒƒå›´æœ‰ä»»ä½•é‡å æˆ–æ¥è§¦ï¼Œå°±è§†ä¸ºé€‰ä¸­
        // ä½¿ç”¨ >= å’Œ <= ç¡®ä¿å…‰æ ‡åœ¨å…¬å¼è¾¹ç¼˜æ—¶ä¹Ÿæ˜¾ç¤ºæºç 
        if (range.from <= to && range.to >= from) {
          return true;
        }
      }
      return false;
    };
    
    // è®°å½•å·²å¤„ç†çš„åŒºåŸŸï¼Œé¿å…é‡å¤åŒ¹é…
    const processedRanges: Array<{ from: number; to: number }> = [];
    
    // 1. å¤„ç†å—çº§å…¬å¼ $$...$$ï¼ˆæ”¯æŒè·¨è¡Œï¼‰
    const blockMathRegex = /\$\$([\s\S]+?)\$\$/g;
    let blockMatch;
    
    while ((blockMatch = blockMathRegex.exec(doc)) !== null) {
      const from = blockMatch.index;
      const to = from + blockMatch[0].length;
      
      processedRanges.push({ from, to });
      
      // å¦‚æœå…‰æ ‡åœ¨å…¬å¼èŒƒå›´å†…ï¼Œä¸æ¸²æŸ“ï¼ˆæ˜¾ç¤ºæºç ï¼‰
      if (isSelected(from, to)) continue;
      
      const formula = blockMatch[1].trim();
      if (formula) {
        // æ£€æŸ¥æ˜¯å¦è¦†ç›–æ•´è¡Œï¼ˆä»è¡Œé¦–åˆ°è¡Œå°¾ï¼‰
        const fromLine = state.doc.lineAt(from);
        const toLine = state.doc.lineAt(to);
        const isFullLine = from === fromLine.from && to === toLine.to;

        decorations.push(
          Decoration.replace({
            widget: new MathWidget(formula, true), // displayMode = true
            block: isFullLine, // åªæœ‰è¦†ç›–æ•´è¡Œæ—¶æ‰ä½¿ç”¨ block: true
          }).range(from, to)
        );
      }
    }
    
    // 2. å¤„ç†è¡Œå†…å…¬å¼ $...$ï¼ˆæ”¯æŒè·¨è¡Œï¼Œä½†ä¸æ”¯æŒè¿ç»­æ¢è¡Œï¼‰
    // æ”¹è¿›æ­£åˆ™ï¼šå…è®¸å•æ¬¡æ¢è¡Œï¼Œä½†ä¸æ”¯æŒè¿ç»­æ¢è¡Œï¼ˆæ®µè½åˆ†éš”ï¼‰ï¼Œä»¥é¿å…è¯¯åˆ¤æ™®é€šæ–‡æœ¬ä¸­çš„ç¾å…ƒç¬¦å·
    const inlineMathRegex = /(?<!\\|\$)\$(?!\$)((?:[^$\n]|\n(?!\n))+?)(?<!\\|\$)\$(?!\$)/g;
    let match;
    while ((match = inlineMathRegex.exec(doc)) !== null) {
      const from = match.index;
      const to = from + match[0].length;
      
      // è·³è¿‡å·²å¤„ç†çš„åŒºåŸŸï¼ˆå—çº§å…¬å¼ï¼‰
      const isProcessed = processedRanges.some(
        (range: { from: number; to: number }) => from >= range.from && to <= range.to
      );
      if (isProcessed) continue;
      
      // å¦‚æœå…‰æ ‡åœ¨å…¬å¼èŒƒå›´å†…ï¼Œä¸æ¸²æŸ“ï¼ˆæ˜¾ç¤ºæºç ï¼‰
      if (isSelected(from, to)) continue;
      
      const formula = match[1].trim();
      if (formula) {
        // æ£€æŸ¥æ˜¯å¦è¦†ç›–æ•´è¡Œï¼ˆä»è¡Œé¦–åˆ°è¡Œå°¾ï¼‰
        const fromLine = state.doc.lineAt(from);
        const toLine = state.doc.lineAt(to);
        const isFullLine = from === fromLine.from && to === toLine.to;
        
        // å¦‚æœè·¨è¡Œä½†ä¸æ˜¯æ•´è¡Œï¼Œåˆ™æ— æ³•æ¸²æŸ“ï¼ˆCodeMirror é™åˆ¶ï¼‰
        // ä½†å¦‚æœæ˜¯æ•´è¡Œï¼ˆä¾‹å¦‚ $ \n math \n $ï¼‰ï¼Œåˆ™å¯ä»¥ä½œä¸º block æ¸²æŸ“
        if (fromLine.number !== toLine.number && !isFullLine) {
          continue;
        }

        decorations.push(
          Decoration.replace({
            widget: new MathWidget(formula, isFullLine), // å¦‚æœæ˜¯æ•´è¡Œï¼Œåˆ™ä½¿ç”¨ displayMode
            block: isFullLine, // åªæœ‰è¦†ç›–æ•´è¡Œæ—¶æ‰ä½¿ç”¨ block: true
          }).range(from, to)
        );
      }
    }
    
    return Decoration.set(decorations.sort((a, b) => a.from - b.from), true);
  } catch (e) {
    console.error("Error creating math decorations:", e);
    return Decoration.none;
  }
}

// æ‚¬æŒ‚æ ‡è®° Widget - åœ¨å·¦ä¾§ gutter æ˜¾ç¤ºæ ‡è®°ç¬¦å·
class HangingMarkWidget extends WidgetType {
  constructor(readonly mark: string) {
    super();
  }

  eq(other: HangingMarkWidget) {
    return other.mark === this.mark;
  }

  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting-hanging";
    span.textContent = this.mark;
    return span;
  }

  ignoreEvent() {
    return true;
  }
}

// å®‰å…¨åˆ›å»ºéšè—è£…é¥°çš„è¾…åŠ©å‡½æ•°
function createHiddenDecoration(state: EditorState, from: number, to: number, decorations: any[]) {
  // ç¡®ä¿ä¸è·¨è¡Œ
  if (from >= to) return;
  const fromLine = state.doc.lineAt(from).number;
  const toLine = state.doc.lineAt(to).number;
  if (fromLine !== toLine) return;
  // æ£€æŸ¥èŒƒå›´å†…æ˜¯å¦æœ‰æ¢è¡Œç¬¦
  const text = state.doc.sliceString(from, to);
  if (text.includes('\n')) return;
  
  decorations.push(
    Decoration.mark({ class: "cm-formatting-hidden" }).range(from, to)
  );
}

// éšè—æ‰€æœ‰è¯­æ³•æ ‡è®°ï¼ˆç”¨äºé˜…è¯»æ¨¡å¼ï¼‰
function createReadingModeDecorations(state: EditorState): DecorationSet {
  try {
    const decorations: any[] = [];
    
    // éå†è¯­æ³•æ ‘ï¼Œéšè—æ‰€æœ‰è¯­æ³•æ ‡è®°
    syntaxTree(state).iterate({
      enter: (node) => {
        const nodeType = node.name;
        
        if (nodeType === "HeaderMark" || 
            nodeType === "EmphasisMark" || 
            nodeType === "StrikethroughMark" || 
            nodeType === "CodeMark") {
          createHiddenDecoration(state, node.from, node.to, decorations);
        }
      },
    });
    
    return Decoration.set(decorations, true);
  } catch (e) {
    console.error("Error creating reading mode decorations:", e);
    return Decoration.none;
  }
}

// é˜…è¯»æ¨¡å¼ Plugin - å§‹ç»ˆéšè—æ‰€æœ‰è¯­æ³•æ ‡è®°
const readingModePlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet;
    
    constructor(view: EditorView) {
      this.decorations = createReadingModeDecorations(view.state);
    }
    
    update(update: ViewUpdate) {
      if (update.docChanged) {
        this.decorations = createReadingModeDecorations(update.state);
      }
    }
  },
  {
    decorations: (v) => v.decorations,
  }
);

// åˆ›å»º Live Preview è£…é¥° - å…‰æ ‡æ‰€åœ¨è¡Œæˆ–é€‰æ‹©åŒºåŸŸæ˜¾ç¤ºæºç 
// isMouseSelecting: é¼ æ ‡æ‹–æ‹½ä¸­æ—¶ï¼Œä¸æ˜¾ç¤º tokensï¼ˆé¿å…é—ªçƒï¼‰
function createLivePreviewDecorations(view: EditorView, isMouseSelecting: boolean): DecorationSet {
  try {
    const decorations: any[] = [];
    const { state } = view;
    const selection = state.selection;
    
    // æ”¶é›†æ‰€æœ‰éœ€è¦æ˜¾ç¤ºæºç çš„è¡Œå·
    const activeLineNumbers = new Set<number>();
    
    // å§‹ç»ˆæ ¹æ®å½“å‰é€‰æ‹©è®¡ç®—æ¿€æ´»è¡Œï¼ˆé¼ æ ‡æ‹–æ‹½æ—¶ä¹Ÿä¿æŒï¼‰
    for (const range of selection.ranges) {
      // å…‰æ ‡æ‰€åœ¨è¡Œï¼ˆå³ä½¿æ²¡æœ‰é€‰æ‹©ï¼‰
      const cursorLine = state.doc.lineAt(range.head).number;
      activeLineNumbers.add(cursorLine);
      
      // å¦‚æœæœ‰é€‰æ‹©ï¼Œæ·»åŠ é€‰æ‹©èŒƒå›´è¦†ç›–çš„æ‰€æœ‰è¡Œ
      if (range.from !== range.to) {
        const fromLine = state.doc.lineAt(range.from).number;
        const toLine = state.doc.lineAt(range.to).number;
        for (let lineNum = fromLine; lineNum <= toLine; lineNum++) {
          activeLineNumbers.add(lineNum);
        }
      }
    }
    
    // isMouseSelecting ç°åœ¨åªç”¨äºæ§åˆ¶æ‚¬æŒ‚æ ‡è®°çš„æ˜¾ç¤ºï¼Œä¸å½±å“è¡Œå†…æ ‡è®°
    void isMouseSelecting; // æ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œé¿å… lint è­¦å‘Š
    
    // è®°å½•æ¯è¡Œæ˜¯å¦å·²æ·»åŠ æ‚¬æŒ‚æ ‡è®°ï¼ˆé¿å…é‡å¤ï¼‰
    const lineHangingMarks = new Map<number, boolean>();
    
    // éå†è¯­æ³•æ ‘ï¼Œå¤„ç†è¯­æ³•æ ‡è®°
    syntaxTree(state).iterate({
      enter: (node) => {
        const nodeType = node.name;
        
        // åªå¤„ç†ç‰¹å®šçš„æ ‡è®°ç±»å‹
        if (nodeType !== "HeaderMark" && 
            nodeType !== "EmphasisMark" && 
            nodeType !== "StrikethroughMark" && 
            nodeType !== "CodeMark" &&
            nodeType !== "ListMark" &&
            nodeType !== "QuoteMark") {
          return;
        }
        
        const lineNum = state.doc.lineAt(node.from).number;
        const isActive = activeLineNumbers.has(lineNum);
        const markText = state.doc.sliceString(node.from, node.to);
        
        // è¡Œé¦–æ ‡è®°ï¼ˆHeaderMark, ListMark, QuoteMarkï¼‰- ä½¿ç”¨æ‚¬æŒ‚å¸ƒå±€
        const isBlockMark = nodeType === "HeaderMark" || nodeType === "ListMark" || nodeType === "QuoteMark";
        
        if (isBlockMark) {
          if (isActive) {
            // åªåœ¨è¡Œé¦–æ·»åŠ ä¸€æ¬¡æ‚¬æŒ‚æ ‡è®°
            if (!lineHangingMarks.has(lineNum)) {
              lineHangingMarks.set(lineNum, true);
              const line = state.doc.line(lineNum);
              decorations.push(
                Decoration.widget({
                  widget: new HangingMarkWidget(markText),
                  side: -1,
                }).range(line.from)
              );
            }
          }
          // è¡Œé¦–æ ‡è®°å§‹ç»ˆéšè—åŸå§‹æ–‡æœ¬
          createHiddenDecoration(state, node.from, node.to, decorations);
        } else {
          // è¡Œå†…æ ‡è®°ï¼ˆEmphasisMark, StrikethroughMark, CodeMarkï¼‰- ä½¿ç”¨ max-width åŠ¨ç”»
          // ç¡®ä¿ä¸è·¨è¡Œ
          if (node.from >= node.to) return;
          const fromLine = state.doc.lineAt(node.from).number;
          const toLine = state.doc.lineAt(node.to).number;
          if (fromLine !== toLine) return;
          const text = state.doc.sliceString(node.from, node.to);
          if (text.includes('\n')) return;
          
          // æ ¹æ®æ˜¯å¦æ¿€æ´»è¡Œï¼Œæ·»åŠ ä¸åŒçš„ class
          const className = isActive 
            ? "cm-formatting-inline cm-formatting-inline-visible" 
            : "cm-formatting-inline";
          decorations.push(
            Decoration.mark({ class: className }).range(node.from, node.to)
          );
        }
      },
    });
    
    return Decoration.set(decorations.sort((a, b) => a.from - b.from), true);
  } catch (e) {
    console.error("Error creating live preview decorations:", e);
    return Decoration.none;
  }
}

// Live Preview ViewPlugin - å…‰æ ‡ç§»åŠ¨æˆ–é€‰æ‹©å˜åŒ–æ—¶æ›´æ–°ï¼Œæ”¯æŒé¼ æ ‡æ‹–æ‹½æ£€æµ‹
const livePreviewPlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet;
    lastCursorLine: number = -1;
    view: EditorView;
    
    constructor(view: EditorView) {
      this.view = view;
      this.decorations = createLivePreviewDecorations(view, false);
      this.lastCursorLine = view.state.doc.lineAt(view.state.selection.main.head).number;
      
      // ç›‘å¬é¼ æ ‡äº‹ä»¶
      this.handleMouseDown = this.handleMouseDown.bind(this);
      this.handleMouseUp = this.handleMouseUp.bind(this);
      view.contentDOM.addEventListener('mousedown', this.handleMouseDown);
      document.addEventListener('mouseup', this.handleMouseUp);
    }
    
    handleMouseDown() {
      // é€šè¿‡ StateEffect æ›´æ–°å…¨å±€é¼ æ ‡çŠ¶æ€
      this.view.dispatch({ effects: setMouseSelecting.of(true) });
    }
    
    handleMouseUp() {
      const isSelecting = this.view.state.field(mouseSelectingField, false);
      if (isSelecting) {
        // æ¾æ‰‹åæ›´æ–°çŠ¶æ€ï¼Œè§¦å‘æ‰€æœ‰ StateField é‡æ–°è®¡ç®—
        this.view.dispatch({ effects: setMouseSelecting.of(false) });
      }
    }
    
    update(update: ViewUpdate) {
      // æ›´æ–° view å¼•ç”¨
      this.view = update.view;
      
      const isMouseSelecting = update.state.field(mouseSelectingField, false) ?? false;
      const currentLine = update.state.doc.lineAt(update.state.selection.main.head).number;
      const lineChanged = currentLine !== this.lastCursorLine;
      
      // æ›´æ–°æ¡ä»¶ï¼š
      // 1. æ–‡æ¡£å˜åŒ–
      // 2. å…‰æ ‡æ‰€åœ¨è¡Œå˜åŒ–ï¼ˆä¸”ä¸åœ¨æ‹–æ‹½ä¸­ï¼Œé¿å…æ‹–æ‹½æ—¶é¢‘ç¹æ›´æ–°ï¼‰
      // 3. é¼ æ ‡æ¾å¼€æ—¶ï¼ˆmouseUpï¼‰
      const shouldUpdate = update.docChanged || 
        (lineChanged && !isMouseSelecting) ||
        update.transactions.some(tr => tr.effects.some(e => e.is(setMouseSelecting) && !e.value));
      
      if (shouldUpdate) {
        this.decorations = createLivePreviewDecorations(update.view, isMouseSelecting);
        this.lastCursorLine = currentLine;
      }
    }
    
    destroy() {
      document.removeEventListener('mouseup', this.handleMouseUp);
    }
  },
  {
    decorations: (v) => v.decorations,
  }
);

// ============ Callout é«˜äº®ï¼ˆLive æ¨¡å¼ï¼‰ ============

const CALLOUT_COLORS: Record<string, string> = {
  note: "blue",
  abstract: "blue",
  info: "blue",
  tip: "green",
  success: "green",
  question: "yellow",
  warning: "yellow",
  danger: "red",
  failure: "red",
  bug: "red",
  example: "purple",
  quote: "gray",
  summary: "blue",
};

// Callout type to emoji mapping
const CALLOUT_ICONS: Record<string, string> = {
  note: "ğŸ“",
  abstract: "ğŸ“„",
  summary: "ğŸ“„",
  info: "â„¹ï¸",
  tip: "ğŸ’¡",
  hint: "ğŸ’¡",
  success: "âœ…",
  check: "âœ…",
  done: "âœ…",
  question: "â“",
  help: "â“",
  faq: "â“",
  warning: "âš ï¸",
  caution: "âš ï¸",
  attention: "âš ï¸",
  danger: "ğŸ”´",
  error: "âŒ",
  failure: "âŒ",
  fail: "âŒ",
  missing: "âŒ",
  bug: "ğŸ›",
  example: "ğŸ“‹",
  quote: "ğŸ’¬",
  cite: "ğŸ’¬",
};

// Callout Icon Widget - åœ¨ callout é¦–è¡Œæ˜¾ç¤º emoji å›¾æ ‡
class CalloutIconWidget extends WidgetType {
  constructor(readonly icon: string) {
    super();
  }

  eq(other: CalloutIconWidget) {
    return other.icon === this.icon;
  }

  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-callout-icon";
    span.textContent = this.icon;
    span.style.cssText = "margin-right: 6px; font-size: 1.1em;";
    return span;
  }

  ignoreEvent() {
    return true;
  }
}

const calloutStateField = StateField.define<DecorationSet>({
  create(state) {
    return buildCalloutDecorations(state);
  },
  update(decorations, tr) {
    if (tr.docChanged || tr.selection) {
      return buildCalloutDecorations(tr.state);
    }
    return decorations.map(tr.changes);
  },
  provide: (f) => EditorView.decorations.from(f),
});

function buildCalloutDecorations(state: EditorState): DecorationSet {
  const decorations: any[] = [];
  const doc = state.doc;
  const lineCount = doc.lines;

  let lineNo = 1;
  while (lineNo <= lineCount) {
    const line = doc.line(lineNo);
    // Support both word types (note, tip) and emoji types (ğŸ“, ğŸ’¡)
    const match = line.text.match(/^>\s*\[!([^\]]+)\]/);
    if (!match) {
      lineNo++;
      continue;
    }

    const rawType = match[1].trim();
    const type = rawType.toLowerCase();
    // For emoji types (non-word characters), default to blue; otherwise use predefined colors
    const isEmojiType = !/^\w+$/.test(rawType);
    const color = isEmojiType ? "blue" : (CALLOUT_COLORS[type] || "gray");
    
    // Get icon: use the emoji directly if it's an emoji type, otherwise lookup from CALLOUT_ICONS
    const icon = isEmojiType ? rawType : (CALLOUT_ICONS[type] || "ğŸ“");

    // æ”¶é›†è¿™ä¸ª callout å—çš„æ‰€æœ‰è¡Œ
    const calloutLines: { from: number }[] = [{ from: line.from }];

    // åç»­è¿ç»­ä»¥ '>' å¼€å¤´çš„è¡Œè§†ä¸ºåŒä¸€ä¸ª callout çš„å†…å®¹è¡Œ
    let nextLineNo = lineNo + 1;
    while (nextLineNo <= lineCount) {
      const nextLine = doc.line(nextLineNo);
      if (/^>\s*/.test(nextLine.text) || nextLine.text.trim() === "") {
        calloutLines.push({ from: nextLine.from });
        nextLineNo++;
      } else {
        break;
      }
    }

    // ç»™æ¯è¡Œæ·»åŠ è£…é¥°ï¼Œé¦–è¡ŒåŠ  callout-firstï¼Œæœ«è¡ŒåŠ  callout-last
    calloutLines.forEach((l, idx) => {
      let cls = `callout callout-${color}`;
      if (idx === 0) {
        cls += " callout-first";
        // æŠŠ [!type] æ›¿æ¢æˆ emoji å›¾æ ‡
        // æ‰¾åˆ° [!type] çš„ä½ç½®å¹¶æ›¿æ¢
        const headerMatch = doc.line(lineNo).text.match(/^(>\s*)(\[![^\]]+\])(\s*)/);
        if (headerMatch) {
          const bracketStart = line.from + headerMatch[1].length;
          const bracketEnd = bracketStart + headerMatch[2].length;
          // ç”¨ emoji æ›¿æ¢ [!type]
          decorations.push(
            Decoration.replace({
              widget: new CalloutIconWidget(icon),
            }).range(bracketStart, bracketEnd)
          );
        }
      }
      if (idx === calloutLines.length - 1) cls += " callout-last";
      decorations.push(Decoration.line({ class: cls }).range(l.from));
    });

    lineNo = nextLineNo;
  }

  return Decoration.set(decorations.sort((a, b) => a.from - b.from), true);
}

// Markdown æ ·å¼è£…é¥°
const markdownStylePlugin = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet;
    
    constructor(view: EditorView) {
      this.decorations = this.buildDecorations(view);
    }
    
    update(update: ViewUpdate) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    
    buildDecorations(view: EditorView): DecorationSet {
      const decorations: any[] = [];
      const { state } = view;
      
      syntaxTree(state).iterate({
        enter: (node) => {
          const nodeType = node.name;
          
          if (nodeType === "ATXHeading1") {
            decorations.push(Decoration.mark({ class: "cm-header-1" }).range(node.from, node.to));
            decorations.push(Decoration.line({ class: "cm-heading-line" }).range(node.from));
          } else if (nodeType === "ATXHeading2") {
            decorations.push(Decoration.mark({ class: "cm-header-2" }).range(node.from, node.to));
            decorations.push(Decoration.line({ class: "cm-heading-line" }).range(node.from));
          } else if (nodeType === "ATXHeading3") {
            decorations.push(Decoration.mark({ class: "cm-header-3" }).range(node.from, node.to));
            decorations.push(Decoration.line({ class: "cm-heading-line" }).range(node.from));
          } else if (nodeType === "ATXHeading4" || nodeType === "ATXHeading5" || nodeType === "ATXHeading6") {
            decorations.push(Decoration.mark({ class: "cm-header-4" }).range(node.from, node.to));
            decorations.push(Decoration.line({ class: "cm-heading-line" }).range(node.from));
          } else if (nodeType === "StrongEmphasis") {
            decorations.push(Decoration.mark({ class: "cm-strong" }).range(node.from, node.to));
          } else if (nodeType === "Emphasis") {
            decorations.push(Decoration.mark({ class: "cm-emphasis" }).range(node.from, node.to));
          } else if (nodeType === "Strikethrough") {
            decorations.push(Decoration.mark({ class: "cm-strikethrough" }).range(node.from, node.to));
          } else if (nodeType === "InlineCode") {
            decorations.push(Decoration.mark({ class: "cm-code" }).range(node.from, node.to));
          } else if (nodeType === "Link") {
            decorations.push(Decoration.mark({ class: "cm-link" }).range(node.from, node.to));
          } else if (nodeType === "URL") {
            decorations.push(Decoration.mark({ class: "cm-url" }).range(node.from, node.to));
          }
        },
      });
      
      return Decoration.set(decorations, true);
    }
  },
  {
    decorations: (v) => v.decorations,
  }
);

// ============ è¯­éŸ³è¾“å…¥æµå¼é¢„è§ˆ ============

const setVoicePreview = StateEffect.define<{ from: number; text: string }>();
const clearVoicePreview = StateEffect.define<null | void>();

class VoicePreviewWidget extends WidgetType {
  readonly text: string;

  constructor(text: string) {
    super();
    this.text = text;
  }

  eq(other: VoicePreviewWidget) {
    return other.text === this.text;
  }

  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-voice-preview";
    span.textContent = this.text;
    return span;
  }

  ignoreEvent() {
    return true;
  }
}

const voicePreviewField = StateField.define<DecorationSet>({
  create() {
    return Decoration.none;
  },
  update(value, tr) {
    let deco = value;

    for (const effect of tr.effects) {
      if (effect.is(setVoicePreview)) {
        const { from, text } = effect.value;
        if (!text) {
          deco = Decoration.none;
        } else {
          deco = Decoration.set([
            Decoration.widget({
              widget: new VoicePreviewWidget(text),
              side: 1,
            }).range(from),
          ]);
        }
      }

      if (effect.is(clearVoicePreview)) {
        deco = Decoration.none;
      }
    }

    if (tr.docChanged && deco !== Decoration.none) {
      deco = deco.map(tr.changes);
    }

    return deco;
  },
  provide: (f) => EditorView.decorations.from(f),
});

const voicePreviewTheme = EditorView.baseTheme({
  ".cm-voice-preview": {
    color: "hsl(var(--muted-foreground))",
    opacity: 0.8,
    fontStyle: "italic",
  },
});

export const CodeMirrorEditor = forwardRef<CodeMirrorEditorRef, CodeMirrorEditorProps>(
  function CodeMirrorEditor({ content, onChange, className = "", isDark = false, viewMode, livePreview }, ref) {
  // å…¼å®¹æ—§çš„ livePreview propï¼Œä¼˜å…ˆä½¿ç”¨ viewMode
  const effectiveMode: ViewMode = viewMode ?? (livePreview === false ? 'source' : 'live');
  const isReadOnly = effectiveMode === 'reading';
  const shouldRenderWidgets = effectiveMode !== 'source'; // reading å’Œ live éƒ½æ¸²æŸ“ widgets
  // reading æ¨¡å¼ï¼šå§‹ç»ˆéšè— tokensï¼ˆåªè¯»ï¼Œæ— éœ€æ˜¾ç¤ºï¼‰
  // live æ¨¡å¼ï¼šéšè— tokensï¼Œä½†å…‰æ ‡/é€‰æ‹©è¡Œæ˜¾ç¤º
  // source æ¨¡å¼ï¼šå§‹ç»ˆæ˜¾ç¤º tokens
  const shouldHideTokensAlways = effectiveMode === 'reading'; // é˜…è¯»æ¨¡å¼å§‹ç»ˆéšè—
  const shouldHideTokensWithCursor = effectiveMode === 'live'; // å®æ—¶æ¨¡å¼å…‰æ ‡è¡Œæ˜¾ç¤º
  
  const containerRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);
  const isExternalChange = useRef(false);
  const lastInternalContent = useRef<string>(content); // è·Ÿè¸ªç¼–è¾‘å™¨å†…éƒ¨çš„æœ€æ–°å†…å®¹
  
  const { openVideoNoteTab, openPDFTab, fileTree, openFile } = useFileStore();
  const { openSecondaryPdf } = useSplitStore();
  const { setSplitView } = useUIStore();
  
  // å¤„ç† WikiLink åŒå‘é“¾æ¥ç‚¹å‡»
  const handleWikiLinkClick = useCallback((linkName: string) => {
    // åœ¨æ–‡ä»¶æ ‘ä¸­æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
    const findFile = (entries: typeof fileTree): string | null => {
      for (const entry of entries) {
        if (entry.is_dir && entry.children) {
          const found = findFile(entry.children);
          if (found) return found;
        } else if (!entry.is_dir) {
          const fileName = entry.name.replace(".md", "");
          if (fileName.toLowerCase() === linkName.toLowerCase()) {
            return entry.path;
          }
        }
      }
      return null;
    };
    
    const filePath = findFile(fileTree);
    if (filePath) {
      openFile(filePath);
    } else {
      console.log(`ç¬”è®°ä¸å­˜åœ¨: ${linkName}`);
    }
  }, [fileTree, openFile]);
  
  // å¤„ç† Bç«™é“¾æ¥ç‚¹å‡»
  const handleBilibiliLinkClick = useCallback((url: string) => {
    if (url.includes('bilibili.com/video/') || url.includes('b23.tv')) {
      openVideoNoteTab(url);
    }
  }, [openVideoNoteTab]);
  
  // å¤„ç† lumina:// PDF é“¾æ¥ç‚¹å‡»
  const handleLuminaLinkClick = useCallback((href: string, ctrlKey: boolean) => {
    const parsed = parseLuminaLink(href);
    if (parsed && parsed.file) {
      if (ctrlKey) {
        // Ctrl+Click: åˆ†æ æ‰“å¼€ PDF
        setSplitView(true);
        openSecondaryPdf(parsed.file, parsed.page || 1, parsed.id);
      } else {
        // æ™®é€šç‚¹å‡»: åœ¨ä¸»è§†å›¾æ‰“å¼€
        openPDFTab(parsed.file);
      }
    }
  }, [setSplitView, openSecondaryPdf, openPDFTab]);

  // æš´éœ²æ»šåŠ¨æ§åˆ¶æ–¹æ³•
  useImperativeHandle(ref, () => ({
    getScrollLine: () => {
      const view = viewRef.current;
      if (!view) return 1;
      // è·å–å¯è§åŒºåŸŸç¬¬ä¸€è¡Œ
      const firstVisiblePos = view.lineBlockAtHeight(
        view.scrollDOM.scrollTop
      ).from;
      return view.state.doc.lineAt(firstVisiblePos).number;
    },
    scrollToLine: (line: number) => {
      const view = viewRef.current;
      if (!view) return;
      const lineCount = view.state.doc.lines;
      const targetLine = Math.min(Math.max(1, line), lineCount);
      const pos = view.state.doc.line(targetLine).from;
      view.dispatch({
        effects: EditorView.scrollIntoView(pos, { y: "start" })
      });
    }
  }), []);
  
  // åˆ›å»ºç¼–è¾‘å™¨
  useEffect(() => {
    if (!containerRef.current) return;
    
    const updateListener = EditorView.updateListener.of((update) => {
      if (update.docChanged && !isExternalChange.current) {
        const newContent = update.state.doc.toString();
        lastInternalContent.current = newContent; // è®°å½•å†…éƒ¨å˜æ›´
        onChange(newContent);
      }
    });
    
    const state = EditorState.create({
      doc: content,
      extensions: [
        // é˜…è¯»æ¨¡å¼è®¾ä¸ºåªè¯»
        ...(isReadOnly ? [EditorState.readOnly.of(true)] : []),
        // é¼ æ ‡æ‹–æ‹½çŠ¶æ€ï¼ˆç”¨äºå®æ—¶æ¨¡å¼ï¼‰
        mouseSelectingField,
        history(),
        keymap.of([...defaultKeymap, ...historyKeymap]),
        markdown({ base: markdownLanguage }),
        editorTheme,  // ä½¿ç”¨ CSS å˜é‡ï¼Œè‡ªåŠ¨é€‚åº”ä¸»é¢˜
        voicePreviewField,
        voicePreviewTheme,
        // WikiLink è£…é¥°ï¼ˆæ‰€æœ‰æ¨¡å¼éƒ½éœ€è¦ï¼‰
        wikiLinkStateField,
        // æ¸²æŸ“ widgetsï¼ˆreading å’Œ live æ¨¡å¼ï¼‰
        ...(shouldRenderWidgets
          ? [
              mathStateField,
              tableStateField,
              codeBlockStateField,
              calloutStateField,
            ]
          : []),
        // é˜…è¯»æ¨¡å¼ï¼šå§‹ç»ˆéšè—æ‰€æœ‰è¯­æ³•æ ‡è®°
        ...(shouldHideTokensAlways ? [readingModePlugin] : []),
        // å®æ—¶æ¨¡å¼ï¼šéšè—è¯­æ³•æ ‡è®°ï¼Œå…‰æ ‡/é€‰æ‹©è¡Œé™¤å¤–
        ...(shouldHideTokensWithCursor ? [livePreviewPlugin] : []),
        markdownStylePlugin,
        updateListener,
        EditorView.lineWrapping,
      ],
    });
    
    const view = new EditorView({
      state,
      parent: containerRef.current,
    });
    
    viewRef.current = view;
    
    return () => {
      view.destroy();
      viewRef.current = null;
    };
  }, [isDark, effectiveMode]);
  
  // åŒæ­¥å¤–éƒ¨å†…å®¹å˜åŒ–ï¼ˆåªå¤„ç†çœŸæ­£çš„å¤–éƒ¨å˜æ›´ï¼Œä¾‹å¦‚åˆ‡æ¢æ–‡ä»¶ã€æ’¤é”€ç­‰ï¼‰
  useEffect(() => {
    const view = viewRef.current;
    if (!view) return;
    
    // å¦‚æœ content å’Œ lastInternalContent ç›¸åŒï¼Œè¯´æ˜æ˜¯ç¼–è¾‘å™¨å†…éƒ¨å˜æ›´è§¦å‘çš„ï¼Œè·³è¿‡
    if (content === lastInternalContent.current) {
      return;
    }
    
    const currentContent = view.state.doc.toString();
    if (currentContent !== content) {
      isExternalChange.current = true;
      
      // ä¿å­˜å…‰æ ‡ä½ç½®
      const selection = view.state.selection;
      const cursorPos = selection.main.head;
      
      view.dispatch({
        changes: {
          from: 0,
          to: currentContent.length,
          insert: content,
        },
        // å°è¯•æ¢å¤å…‰æ ‡ä½ç½®ï¼ˆä¸è¶…è¿‡æ–°å†…å®¹é•¿åº¦ï¼‰
        selection: { anchor: Math.min(cursorPos, content.length) },
      });
      
      lastInternalContent.current = content;
      isExternalChange.current = false;
    }
  }, [content]);
  
  // ç›‘å¬ Ctrl+Click Bç«™é“¾æ¥
  useEffect(() => {
    let timer: ReturnType<typeof setTimeout> | null = null;
    let currentCleanup: (() => void) | null = null;
    
    const handleClick = (e: MouseEvent) => {
      const view = viewRef.current;
      if (!view) return;
      
      const target = e.target as HTMLElement;
      const linkElement = target.closest('a[href]');
      
      // lumina:// é“¾æ¥æ”¯æŒæ™®é€šç‚¹å‡»å’Œ Ctrl+Click
      if (linkElement) {
        const href = linkElement.getAttribute('href') || '';
        
        // å¤„ç† lumina:// PDF é“¾æ¥ï¼ˆæ™®é€šç‚¹å‡»æ‰“å¼€ä¸»è§†å›¾ï¼ŒCtrl+Click åˆ†æ ï¼‰
        if (href.startsWith('lumina://pdf')) {
          e.preventDefault();
          e.stopPropagation();
          console.log('[CodeMirror] æ£€æµ‹åˆ° lumina é“¾æ¥ç‚¹å‡»:', href);
          handleLuminaLinkClick(href, e.ctrlKey || e.metaKey);
          return;
        }
      }
      
      // å¤„ç† WikiLink åŒå‘é“¾æ¥ï¼ˆCtrl+Click è·³è½¬ï¼Œæ™®é€šç‚¹å‡»ç¼–è¾‘ï¼‰
      if (target.classList.contains("cm-wikilink") || target.closest(".cm-wikilink")) {
        const wikiLinkEl = target.classList.contains("cm-wikilink") 
          ? target 
          : target.closest(".cm-wikilink") as HTMLElement;
        const linkName = wikiLinkEl?.getAttribute("data-wikilink");
        
        // åªæœ‰ Ctrl+Click æ‰è·³è½¬ï¼Œæ™®é€šç‚¹å‡»ç»§ç»­ç¼–è¾‘
        if ((e.ctrlKey || e.metaKey) && linkName) {
          e.preventDefault();
          e.stopPropagation();
          console.log('[CodeMirror] Ctrl+Click WikiLink è·³è½¬:', linkName);
          handleWikiLinkClick(linkName);
          return;
        }
        // æ™®é€šç‚¹å‡»ä¸é˜»æ­¢ï¼Œè®©ç¼–è¾‘å™¨æ­£å¸¸å¤„ç†ï¼ˆè¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼‰
      }
      
      // å…¶ä»–é“¾æ¥éœ€è¦ Ctrl+Click
      if (!(e.ctrlKey || e.metaKey)) return;
      
      // å¤„ç† Bç«™é“¾æ¥
      if (linkElement) {
        const href = linkElement.getAttribute('href') || '';
        if (href.includes('bilibili.com/video/') || href.includes('b23.tv')) {
          e.preventDefault();
          e.stopPropagation();
          console.log('[CodeMirror] æ£€æµ‹åˆ°é“¾æ¥å…ƒç´ ç‚¹å‡»:', href);
          handleBilibiliLinkClick(href);
          return;
        }
      }
      
      // æ–¹æ³•2ï¼šæ£€æŸ¥ç‚¹å‡»ä½ç½®é™„è¿‘çš„æ–‡æœ¬å†…å®¹
      const pos = view.posAtCoords({ x: e.clientX, y: e.clientY });
      if (pos === null) return;
      
      // è·å–ç‚¹å‡»ä½ç½®å‰åçš„æ–‡æœ¬ï¼ˆæ‰©å¤§æœç´¢èŒƒå›´ï¼‰
      const from = Math.max(0, pos - 100);
      const to = Math.min(view.state.doc.length, pos + 100);
      const textAround = view.state.doc.sliceString(from, to);
      
      // åŒ¹é… Bç«™é“¾æ¥
      const bilibiliRegex = /(https?:\/\/)?(www\.)?(bilibili\.com\/video\/[A-Za-z0-9]+|b23\.tv\/[A-Za-z0-9]+)/g;
      let match;
      while ((match = bilibiliRegex.exec(textAround)) !== null) {
        const matchStart = from + match.index;
        const matchEnd = matchStart + match[0].length;
        
        // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦åœ¨é“¾æ¥èŒƒå›´å†…ï¼ˆæ”¾å®½åˆ¤æ–­ï¼‰
        if (pos >= matchStart - 5 && pos <= matchEnd + 5) {
          e.preventDefault();
          e.stopPropagation();
          
          let url = match[0];
          if (!url.startsWith('http')) {
            url = 'https://' + url;
          }
          
          console.log('[CodeMirror] æ£€æµ‹åˆ°Bç«™é“¾æ¥ç‚¹å‡»:', url);
          handleBilibiliLinkClick(url);
          return;
        }
      }
    };
    
    // ç­‰å¾…ç¼–è¾‘å™¨åˆ›å»ºåæ·»åŠ ç›‘å¬
    const tryAddListener = () => {
      const view = viewRef.current;
      if (!view) {
        timer = setTimeout(tryAddListener, 100);
        return;
      }
      
      view.contentDOM.addEventListener('click', handleClick);
      currentCleanup = () => view.contentDOM.removeEventListener('click', handleClick);
      console.log('[CodeMirror] Bç«™é“¾æ¥ç‚¹å‡»ç›‘å¬å·²æ·»åŠ ');
    };
    
    tryAddListener();
    
    return () => {
      if (timer) clearTimeout(timer);
      if (currentCleanup) currentCleanup();
    };
  }, [handleWikiLinkClick, handleBilibiliLinkClick, handleLuminaLinkClick, isDark, effectiveMode]);
  
  // ç›‘å¬è¯­éŸ³è¾“å…¥äº‹ä»¶ï¼šç°è‰²æµå¼é¢„è§ˆ + åœ¨å…‰æ ‡å¤„æ’å…¥æ–‡æœ¬
  useEffect(() => {
    const handleInterim = (e: Event) => {
      const view = viewRef.current;
      if (!view) return;

      const detail = (e as CustomEvent<{ text: string }>).detail;
      const text = detail?.text ?? "";

      if (!text) {
        view.dispatch({ effects: clearVoicePreview.of(null) });
        return;
      }

      const pos = view.state.selection.main.head;
      view.dispatch({
        effects: setVoicePreview.of({ from: pos, text }),
      });
    };

    const handleFinal = (e: Event) => {
      const view = viewRef.current;
      if (!view) return;

      const detail = (e as CustomEvent<{ text: string }>).detail;
      const text = detail?.text ?? "";
      if (!text) return;

      const pos = view.state.selection.main.head;
      view.dispatch({
        changes: { from: pos, to: pos, insert: text },
        selection: { anchor: pos + text.length },
        effects: clearVoicePreview.of(null),
      });
    };

    window.addEventListener("voice-input-interim", handleInterim as EventListener);
    window.addEventListener("voice-input-final", handleFinal as EventListener);

    return () => {
      window.removeEventListener("voice-input-interim", handleInterim as EventListener);
      window.removeEventListener("voice-input-final", handleFinal as EventListener);
    };
  }, []);

  // ç›‘å¬é€‰åŒº AI ç¼–è¾‘äº‹ä»¶ï¼šæ„é€  diff å¹¶äº¤ç»™ DiffView
  useEffect(() => {
    const handleSelectionAIEdit = (e: Event) => {
      const view = viewRef.current;
      if (!view) return;

      const detail = (e as CustomEvent<{
        mode: "append_callout" | "replace_selection";
        text: string;
        description?: string;
      }>).detail;
      if (!detail?.text) return;

      const { mode, text, description } = detail;

      const state = view.state;
      const doc = state.doc;
      const sel = state.selection.main;

      const original = doc.toString();
      let modified = original;

      if (mode === "replace_selection") {
        modified = original.slice(0, sel.from) + text + original.slice(sel.to);
      } else if (mode === "append_callout") {
        const insertPos = sel.to;
        modified = original.slice(0, insertPos) + text + original.slice(insertPos);
      }

      if (modified === original) return;

      const { currentFile } = useFileStore.getState();
      if (!currentFile) return;

      const filePath = currentFile;
      const fileName = filePath.split(/[/\\]/).pop() || filePath;

      const { setPendingDiff } = useAIStore.getState();
      setPendingDiff({
        fileName,
        filePath,
        original,
        modified,
        description: description || "é€‰åŒº AI ç¼–è¾‘",
      });
    };

    window.addEventListener("selection-ai-edit", handleSelectionAIEdit as EventListener);
    return () => {
      window.removeEventListener("selection-ai-edit", handleSelectionAIEdit as EventListener);
    };
  }, []);

  // ç›‘å¬é€‰ä¸­æ–‡æœ¬æ€»ç»“æ’å…¥äº‹ä»¶ï¼šåœ¨å½“å‰é€‰åŒºåæ’å…¥ callout å—
  useEffect(() => {
    const handleInsertCallout = (e: Event) => {
      const view = viewRef.current;
      if (!view) return;

      const detail = (e as CustomEvent<{ callout: string }>).detail;
      const callout = detail?.callout ?? "";
      if (!callout) return;

      const sel = view.state.selection.main;
      const insertPos = sel.to;

      view.dispatch({
        changes: { from: insertPos, to: insertPos, insert: callout },
        selection: { anchor: insertPos + callout.length },
      });
    };

    window.addEventListener("insert-summary-callout", handleInsertCallout as EventListener);
    return () => {
      window.removeEventListener("insert-summary-callout", handleInsertCallout as EventListener);
    };
  }, []);
  
  return (
    <div 
      ref={containerRef} 
      className={`codemirror-wrapper h-full overflow-auto ${className}`}
    />
  );
});

export default CodeMirrorEditor;
